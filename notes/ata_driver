ATA DRIVER 
  ATA(Advanced technology advancement) is a technology used for connecting storage devices like hard dives to computer system
	it is of two types :-
		PATA
		SATA
PATA:-
	parallel ATA, it sends 16bits of data at a time from harddive to ram, supports two devices per channel a master and a slave
	it is slower and uses termendous cpu resource because it invloves cpu to transfer data

SATA:-
	serial ATA, it sends data as one bit at a time but at a very fast rate, is way more faster than PATA and does not rely on cpu directly for  data transfer,
	SATA can operate in IDE compatability where it can support PATAdrivers because it emulates behaviour of  a PATA in this mode
	SATA can operate in AHCI mode where it can use modern technologies like DMA and NCQ support

in this os we implement PATA device driver because it is easier to implement for a PATA than SATA

<current state of bootloader at day 5>

ORG	0X7c00
[bits	16]

jmp	start
start:
	cli
	mov	ax,0x00
	mov	ds,ax
	mov	es,ax
	mov	ss,ax
	mov   	sp,0x7c00
	sti
load_tgdt:
	lgdt	[gdt_descriptor]
	mov	eax,cr0
	or	eax,0x01
	mov	cr0,eax
	jmp	0x08:protected_mode
;GDT
load_gdt:
	cli
	lgdt 	[gdt_descriptor]
	;setting protection bit to 1
	mov 	eax,cr0
	or	eax,0x1
	mov	cr0,eax
	jmp	0x8:protected_mode
gdt_null:
	dd 	0x00 	;dword of 0s,32bits of 0s
	dd  	0x00 	;dword of 0x,32bits of 0s

gdt_kernel_code:	 ;meant for cs selector
	;base address is 0x0000 0000
	;segment limit is 0xffff f
	dw	0xffff	;lower 16bits of segment limit
	dw	0x0000	;lower 16bits of base address
	db	0x00	;middle 8bits of base  address
	db	0x9a	;b1000 1010 kernel level system,only excutable,only readable
	db	0xcf 	;b1100 1111 granularity=1(4KiB),protectmod=1, long=0,rserverd=0,
	db 	0x00

gdt_kernel_data:	;meant of ds,ss,es,gs
	 ;base address is 0x0000 0000
	 ;segment limit is 0xffff f
	dw 	0xffff
	dw 	0x0000
	db	0x00
	db	0x92	;b1000 0010 
	db 	0xcf
	db 	0x00
gdt_descriptor:
	dw  gdt_descriptor- gdt_null -1
	dd  gdt_null
[BITS 32]
protected_mode:
	mov 	ebx,1		;lba number	
	mov 	ecx,100		;sector count
;setting es for es:di so that it can be evaluted well for insw and es selector points to second entry in GDT 
	mov	ax,0x10
	mov	es,ax

	mov 	edi,0x0100000
	call   	ata_lba_read
ata_lba_read:
;move sector count (as 8 bit value) to i/o port 0x1f2
;we are using dx to store port numbers because it is instruction encodeing to do so, that if you are using a port above 255 then mov to dx before out
	mov	dx,0x1f2	
	mov	al,cl
	out	dx,al	;cl should represent 100 at this point
	
;lower (0-8) bits or lba number to 0x1f3
	mov	dx,0x1f3
	mov	al,bl	;lower 8 bits of ebx 
	out 	dx,al 
;middle (8-15)bits of lba number to 0x1f4
	mov	dx,0x1f4
	mov	al,bh  
	out	dx,al

;upper (16-23)bits of lba number in 0x1f5
	mov	dx,0x1f5
	mov	eax,ebx
	shr	eax,16	;now eax contains 16bits of valid info al=ebx(16-23), and ah=ebx(24-31) we need al value and ebx(24-27) in al in next out
	out	dx,al

;(24-27)bits of lba number in 0x1f6
	mov	dx,0x1f6
	and	ah,0x0f	;now upper 4bits of ah are zero	
	or	ah,0xe0 ;now upper 4bits of ah contain 0xe
	mov	al,ah ;ah contains bits(24-31)ebx, so we move it to al
	out	dx,al


	mov	dx,0x1f7
	mov	al,0x20
	out 	dx,al
.call_read_sect:
	push	ecx	;100 is pushed to stack(init) it is the number of sectors we want to read below is the code fro reading a single sector
.ata_wait_busy_set_drq_clear:
	mov 	dx,0x1f7
.loop:
	in 	al,dx	;stores value of port 0x1f7 in al
	test	al,0x80	;compares value at al with '1000 0000b'so it checks if the 7th bit is set,if it is set then ATA is BSY(busy)
	jnz	.loop
	test 	al,0x08 ;if 3rd bit is not set then loop back
	jz	.loop

.read_sect:
	mov	cx,0x100	;512/2=256=0x100
	mov	dx, 0x1f0
	cld
	rep	insw		;insw reads 16bit value form 0x1f0 and 0x1f1 and store them to memory address pointed to by es:di and es:di+1
;increment di by 2 and decrement cx by 1 and check if cx is 0 
;the cx part is done by rep, moving of 2 bytes from sector number in bin file to es:di in ram is done by insw
	;add	edi,0x200  donot add this is explained later insw auto increments edi 
	pop 	ecx	
	dec	ecx
	jnz	.call_read_sect

jmp 	0x100000 	;jmps to location 1MiB in ram as cs is adready set
	
times 510-($-$$) db 0
dw	0xaa55

<end of bootloader code>
we will look into assembly code after  protected mode label, 

<snippet begin>
	mov 	ebx,1		;starting sector to read from
	mov	ecx,100		;total number of sectors to read
;code for storing  0x0 to es selector
	mov	ax,0x0		
	mov	es,ax

	;move the location to write sectors into ram to di
	mov	di,0x0100000
	call	ata_lba_read
<snippet end>

this code  sets up the parametes for the call to ata_lba_read , this is a subroutine that we have implemented for taking to ata, to transfer a number of sectors from the current file to ram from a specified starting point.

BEFORE WRITING THE DRIVER FOR ATA WE NEED TO KNOW HOW ATA WORKS AND WHAT IS THE ATA EXPECTING FROM US AND WHAT ALL PORT NUMBERS TO SEND WHAT ALL DATA

I/O PORT 		DESCRIPTION

0x1f0			data port (16bit)
0x1f1			error register
0x1f2			sector count
0x1f3			LBA low byte
0x1f4			LBA mid byte
0x1f5			LBA high byte
0x1f6			drive+mode+bits 24-27
0x1f7			command/status registers

the ata driver expects us  to have a 28bit value that represents the LBA address , we have use 'out' instruction to communicate the neccessary value to neccessary ports

ata_lba_read:
;move sector count (as 8 bit value) to i/o port 0x1f2
;we are using dx to store port numbers because it is instruction encodeing to do so, that if you are using a port above 255 then mov to dx before out
	mov	dx,0x1f2	
	mov	al,cl
	out	dx,al	;cl should represent 100 at this point
	
;lower (0-8) bits or lba number to 0x1f3
	mov	dx,0x1f3
	mov	al,bl	;lower 8 bits of ebx 
	out 	dx,al 
;middle (8-15)bits of lba number to 0x1f4
	mov	dx,0x1f4
	mov	al,bh  
	out	dx,al

;upper (16-23)bits of lba number in 0x1f5
	mov	dx,0x1f5
	mov	eax,ebx
	shr	eax,16	;now eax contains 16bits of valid info al=ebx(16-23), and ah=ebx(24-31) we need al value and ebx(24-27) in al in next out
	out	dx,al

;(24-27)bits of lba number in 0x1f6
	mov	dx,0x1f6
	and	ah,0x0f	;now upper 4bits of ah are zero	
	or	ah,0xe0 ;now upper 4bits of ah contain 0xe
	mov	al,ah ;ah contains bits(24-31)ebx, so we move it to al
	out	dx,al


	mov	dx,0x1f7
	mov	al,0x20
	out 	dx,al
.call_read_sect:
	push	ecx	;100 is pushed to stack(init) it is the number of sectors we want to read below is the code fro reading a single sector
.ata_wait_busy_set_drq_clear:
	mov 	dx,0x1f7
.loop:
	in 	al,dx	;stores value of port 0x1f7 in al
	test	al,0x80	;compares value at al with '1000 0000b'so it checks if the 7th bit is set,if it is set then ATA is BSY(busy)
	jnz	.loop
	test 	al,0x08 ;if 3rd bit is not set then loop back
	jz	.loop

.read_sect:
	mov	cx,0x100	;512/2=256=0x100
	mov	dx, 0x1f0
	cld
	rep	insw		;reads 16bit value form 0x1f0 and 0x1f1 and store them to memory address pointed to by es:di and es:di+1
;increment di by 2 and decrement cx by 1 and check if cx is 0 
;the cx part is done by rep, moving of 2 bytes from sector number in bin file to es:di in ram is done by insw
	pop 	ecx	
	;add	edi,0x200    donot add this comment it out , insw auto increments it (i lost half a day debugging)
	dec	ecx
	jnz	.call_read_sect

jmp 	0x100000 	;jmps to location 1MiB in ram as cs is adready set

we first set the count value into 0x1f2 this is to inform how many sectors we are planning to read to the ata 
	mov	dx, 0x1f2
	mov	al,cl
	out	dx,al
we cannot direcly out to 0x1f2 because it is instruction encoding to ensure that we store  value of ports to dx, and donot use them directly if port number is greater than 0xff 
now what we do here is we move value of 100 which was stored in ecx to 0x1f2  we only need to move cl because we only want to send lower 8bits

we cannot move cl register directly to dx, it is not permitted

	mov 	dx,0x1f3
	mov	al,bl	
	out	dx,al

we move the lower 8 bits of ebx or lower 8 bits of LBA to 0x1f3 in a similar fashion
	mov	dx,0x1f4
	mov	al,bh
	out	dx,al
we move bits (8-15) in a similar fashion to 0x1f4 as metioned in the above table

	mov	dx,0x1f5
	mov	eax,ebx		
	shr	eax,16
	out 	dx,al

we move the entire ebx to eax , what we want is to move bits(16-23)ebx to 0x1f5 , now as eax contains same data as ebx, if we shr(shift right)by 16 bits then the lower 8 bit(al) will contain bits (16-23) of ebx, because lower 16 bits were pushed out and the upper 16 bits are the new lower 16 bits and new upper 16 bits are zeros

	mov	dx,0x1f6
	and	ah,0x0f	
	or 	ah,0xe0
	mov	al,ah
	out	dx,al

what we perform here is that we want to send lower 4bits of ah or (24-27)bits of ebx, or bits (8-11)of current eax as lower 4bits so what we do here is we perform and opreation on ah with 0x0f so lower 4bits are retained and upper 4 bits are 0, 
explantion of what upper 4 bits should account for
	bit  7	always one 1
	bit  6		   1 	we have to set it one for LBA mode
	bit  5		   1	set state(safe)
	bit  4		   0	0=MASTER
	
so upper 4bits corresponds ot 0xe
so to make upper 4 bits 0xe we perform or operation
	so 	or ah,0xe0
here lower 4 bits are untouched and upper 4 bits become 0xe, 
NOTE:
if bit 4 is aldready set(which it is not),then it becomes 0xf, 
	mov	dx,0x1f7
	mov	al,0x20
	out 	dx,al
now this snippet moves 0x20 to port number 0x1f7 
here 0x20 puts ata to the mode where it can read sectors with retry(PIO)
this helps to us to tell ata to try to read sectors using PIO(programmed I/O) ,and if some error occurs retry

so what we did till now is setting up ata for read
0x1f2		sector count		100
0x1f3-0x1f6	LBA(28 bit)	
0x1f6		drive select+mode	
0x1f7		command register	0x20=read PIO

we have to set all the neccessary value now is the act of reading it
we have to perform it a hundred times, and should count this manually,eventhough we pass value 100 to 0x1f2, this is because 0x1f2 will inform ata the number of sectors it has to read, so it will just create interrupts and drq accordingly we should  perform the act of reading a hundred times manually

.call_read_sect:
	push	ecx
.ata_wait_busy_set_drq_clear:
	mov	dx,0x1f7
.loop:
	in 	al,dx
	
	test	al,0x80
	jnz	.loop
	test	al,0x08
	jz	.loop
.read_sect
	mov	cx,0x100
	mov	dx,0x1f0
	cld
	rep	insw
	pop	ecx
	add	edi,0x200
	dec	ecx
	jnz	.call_read_sect

this is the the code for reading one sector ,to be more specific from label .ata_wait_set_drq_clear to rep insw

the other as prologue and epilogue to that in the code snippet is  associated to looping,so what we do here

we push the value of ecx to stack this is to store it in stack so that it will be saved there before read and we can access it after read,during read_sector we will use cx

.ata_wait_busy_set_drq_clear:
	this label till jz .loop actually is more of waiting for interrupts rather than actually writing data, that is for writing data using ata we need to ensure that,  the resource is not busy and drq is set
if not then we should not proceed to transfer data

	mov	dx,0x1f7
.loop:	
	in	al,dx
	test	al,0x80	
	jnz	.loop
	test	al,0x08
	jz	.loop

what we check here is the value of 0x1f7 port, we ensure that bit 7 is cleared and 3rd bit is set, if either of these conditions are not followed we stay in the loop
	we move the contents of dx(0x1f7) to al, we perform test al,0x80
so and operation between 0x80 and value in 0x1f7, if 7th bit is high, then and gives a non zero answer , we stay on loop, so jnz .loop
 
then we perform and operation  test al,0x08 , it performs and operation between al and 0x08 if 3rd bit  is set it will give a non zero value if it is not set we get a zero value , we want it to be set, so we jmp inot loop in zero so jz .loop

.read_sect:
	mov	cx,0x100
	mov	dx,0x1f0
	cld
	rep	insw

this much is associated with moving a single sector, ata deals with 16 bit operations, each sector has 512 bytes we are transfering 2 bytes(16bits) at a time so we have to perform 256 times which is 0x100 and mov dx to value 0x1f0 this is the port  number for reading, cld clears the direction flag  , direction flag 0 means increment forward and std sets direction flag meaning decrement
 rep insw
it should be seen as two parts rep ; repeat the instruction followed till cx equals zero and decrement cx by one after every call
insw means insert word it means to insert 2bytes(16bits) of data into location in ram given by es:di, this is the reason why we set es to 0x10 second entry in gdt so it evaluates to zero, and di is set as 0x100000, 1MiB into ram,
even if we are in 32 bit protected mode, word size is considered to 16 bits in general in x86 assembly espcially when it comes to talking to i/o ports whic talk in 16bits
this snippet will write 1 sector into location specified by es:di

	;;add	di,0x200      donot add this,comment it out was a bug, insw auto incrments edi by 2 
	pop	ecx
	dec	ecx
	jnz	.call_read_sect

and we pop back the stored value of ecx, this for counting how much sectors we copied and how much remains if it is zero we can exit from loop
we decrement ecx, this is to reduce count by one because we wrote 1 sector, then we call the whole operation again for writing next sector if number of sectors to be written to ram is nonzero

	jmp	0x100000
after writing all 100 sectors we jump to location 0x100000 in ram (1MiB), that is where our shellcode correspondign to kernel.asm is loaded in ram, cs is aldready set to point to first entry in gdt, so now it will just update ip to 0x100000, in ram so we can execute code that we wrote for kernel
